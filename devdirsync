#!/usr/bin/env python3

from os import listdir, makedirs, path
from typing import List
import json
import subprocess
import sys

from pathos.multiprocessing import ProcessPool as Pool


EXCLUDED_DEV_CATEGORIES = ["Local", "Sandbox"]
PATH_TO_DEV_DIR = path.expanduser("~/Developer")
PATH_TO_DATA_FILE = path.expanduser("~/Developer/.syncdata.json")


def main_pull_from() -> None:
    print("Reading .sync.data.json...")
    if not path.isfile(PATH_TO_DATA_FILE):
        print("Path to data file invalid!", file=sys.stderr)
        print("Place .syncdata.json into ~/Developer/ directory", file=sys.stderr)
        print("or run devdirsync push first.", file=sys.stderr)
        exit(1)
    dev_dir_tree = {}
    with open(PATH_TO_DATA_FILE, "r") as f:
        dev_dir_tree |= json.load(f)
    print("Reading .sync.data.json done.")

    print("Generating directory structure for ~/Developer...")
    generate_dir_structure(dev_dir_tree)
    print("Generating directory structure for ~/Developer done.")
    print("Attempting to clone repos into ~/Developer...")
    get_repos_into_dev_dir(dev_dir_tree)
    print("Attempting to clone repos into ~/Developer done.")
    print()
    print_repos_needing_manual_sync(dev_dir_tree)


def main_push_to() -> None:
    dev_dir_tree = {}
    path_to_repos = []
    repo_data = []
    print("Scanning ~/Developer directory... (you may be prompted to authenticate to Git remote servers)")
    get_dir_tree(PATH_TO_DEV_DIR, dev_dir_tree, 2, path_to_repos, repo_data, EXCLUDED_DEV_CATEGORIES)
    repo_info = get_git_information_for_repos_with_remote(path_to_repos)
    merge_tree_info_to_dev_dir_tree(repo_info, dev_dir_tree)
    print("Scanning ~/Developer directory done.")
    print("Writing scanned results to ~/Developer.syncdata.json...")
    with open(PATH_TO_DATA_FILE, "w") as f:
        json.dump(dev_dir_tree, f, sort_keys=True, indent=2)
    print("Writing scanned results to ~/Developer.syncdata.json done.")
    print_repos_needing_manual_sync(dev_dir_tree)


def generate_dir_structure(dev_dir_tree: dict) -> None:
    for category in dev_dir_tree:
        for subcategory in dev_dir_tree[category]:
            makedirs(f"{PATH_TO_DEV_DIR}/{category}/{subcategory}", exist_ok=True)


def get_repos_into_dev_dir(dev_dir_tree: dict) -> None:
    repo_info = []
    for category in dev_dir_tree:
        for subcategory in dev_dir_tree[category]:
            for repo in dev_dir_tree[category][subcategory]:
                repo_info.append(dev_dir_tree[category][subcategory][repo])
    with Pool() as pool:
        pool.map(get_repo_into_dev_dir, repo_info)


def print_repos_needing_manual_sync(dev_dir_tree: dict) -> None:
    no_remote = {}
    otherwise_needs_manual_sync = {}
    for category in dev_dir_tree:
        for subcategory in dev_dir_tree[category]:
            for repo in dev_dir_tree[category][subcategory]:
                repo_status = dev_dir_tree[category][subcategory][repo]
                if not repo_status["is_git"]:
                    add_to_manual_sync_dict(category, subcategory, repo, no_remote)
                elif repo_status["needs_manual_sync"]:
                    add_to_manual_sync_dict(category, subcategory, repo, otherwise_needs_manual_sync)
    print("The following repos do not have a remote:")
    print_manual_sync_dict_tree(no_remote)
    print("The following repos have a remote but still need manual sync for other reasons:")
    print_manual_sync_dict_tree(otherwise_needs_manual_sync)


def add_to_manual_sync_dict(category: str, subcategory: str, repo: str, manual_sync_dict: dict) -> None:
    if category not in manual_sync_dict:
        manual_sync_dict[category] = {}
    if subcategory not in manual_sync_dict[category]:
        manual_sync_dict[category][subcategory] = []
    manual_sync_dict[category][subcategory].append(repo)


def print_manual_sync_dict_tree(manual_sync_dict: dict) -> None:
    for category in manual_sync_dict:
        print(f"\t{category}")
        for subcategory in manual_sync_dict[category]:
            print(f"\t\t{subcategory}")
            for repo in manual_sync_dict[category][subcategory]:
                print(f"\t\t\t{repo}")
            print()


def get_repo_into_dev_dir(repo: dict) -> None:
    path_to_repo_parent = f"{PATH_TO_DEV_DIR}/{repo["repo_category"]}/{repo["repo_subcategory"]}"

    # Check if repo already exists
    if path.isdir(f"{path_to_repo_parent}/{repo["repo_name"]}"):
        return

    # Check if repo is not a git repo
    if not repo["is_git"]:
        leave_repo_pull_note(repo, path_to_repo_parent)
        return

    # Otherwise, try to clone repo
    clone_repo(repo, path_to_repo_parent)

    # Cloned repos may need manual sync, i.e. unsaved changes from other computers
    if repo["needs_manual_sync"]:
        leave_repo_pull_note(repo, path_to_repo_parent)


def leave_repo_pull_note(repo: dict, path_to_repo_parent: str) -> None:
    path_to_repo = f"{path_to_repo_parent}/{repo["repo_name"]}"
    makedirs(path_to_repo, exist_ok=True)
    subprocess.run(f"cd {path_to_repo} && echo \"NEEDS MANUAL SYNC\" > AAA_SYNC_NOTE.txt", shell=True)


def clone_repo(repo: dict, path_to_repo_parent: str):
    clone_return_val = subprocess.run(f"cd {path_to_repo_parent} && git clone {repo["url"]}", shell=True, capture_output=True)
    if clone_return_val.returncode != 0:
        leave_repo_pull_note(repo, path_to_repo_parent)


def main_status() -> None:
    if not path.isfile(PATH_TO_DATA_FILE):
        main_push_to()
    pass  # TODO CONTINUE


def get_dir_tree(path_to_dir: str, tree: dict, recurse: int, path_to_repos: List[str], repo_data: List[dict], excluded_names: List[str] = []):
    if recurse < 0:
        tree["is_git"] = True if ".git" in get_subdirs(path_to_dir) else False
        if tree["is_git"]: path_to_repos.append(path_to_dir)
        path_breakup = path_to_dir.split("/")
        tree["repo_category"], tree["repo_subcategory"], tree["repo_name"] = path_breakup[-3], path_breakup[-2], path_breakup[-1]
        return
    subdirs = get_subdirs(path_to_dir, excluded_names)
    for subdir in subdirs:
        tree[subdir] = {}
        get_dir_tree(f"{path_to_dir}/{subdir}", tree[subdir], recurse - 1, path_to_repos, repo_data)


def get_subdirs(path_to_dir: str, excluded_names: List[str] = []) -> List[str]:
    subdirectories = []
    for directory in listdir(path_to_dir):
        if path.isdir(f"{path_to_dir}/{directory}") and directory not in excluded_names:
            subdirectories.append(directory)
    return subdirectories


def get_git_information_for_repos_with_remote(path_to_repos: List[str]) -> List[dict]:
    with Pool() as pool:
        return pool.map(get_git_information_for_repo, path_to_repos)


def get_git_information_for_repo(path_to_repo_dir: str) -> dict:
    repo_datum = {}
    path_breakup = path_to_repo_dir.split("/")

    repo_datum["repo_category"], repo_datum["repo_subcategory"], repo_datum["repo_name"] = path_breakup[-3], path_breakup[-2], path_breakup[-1]
    get_remote_return_val = subprocess.run(f"cd {path_to_repo_dir} && git remote get-url origin", shell=True, capture_output=True, text=True)
    repo_datum["url"] = get_remote_return_val.stdout.strip()
    fetch_return_value = subprocess.run(f"cd {path_to_repo_dir} && git fetch", shell=True, capture_output=True, text=True)
    repo_datum["returncode"] = fetch_return_value.returncode
    repo_datum["stdout"] = fetch_return_value.stdout
    repo_datum["stderr"] = fetch_return_value.stderr
    repo_datum["is_git"] = True

    if repo_datum["returncode"] == 0:
        git_status_return_value = subprocess.run(f"cd {path_to_repo_dir} && git status", shell=True, capture_output=True, text=True)
        repo_datum["needs_manual_sync"] = "nothing to commit, working tree clean" not in git_status_return_value.stdout
    else:
        repo_datum["needs_manual_sync"] = True
    return repo_datum


def merge_tree_info_to_dev_dir_tree(repo_info: List[dict], dev_dir_tree: dict) -> None:
    for repo in repo_info:
        dev_dir_tree[repo["repo_category"]][repo["repo_subcategory"]][repo["repo_name"]] = repo


def print_help_and_exit() -> None:
    print("USAGE: devdirsync <pull|push|status>")
    exit(1)


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print_help_and_exit()

    action = sys.argv[1]

    if action == "pull":
        main_pull_from()
    elif action == "push":
        main_push_to()
    elif action == "status":
        main_status()
    else:
        print_help_and_exit()
